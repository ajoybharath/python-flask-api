How To

We are going to build & test Python web api service with Jenkins CI (continuous integration) pipeline (using Jenkinsfile)

    1. build a small HelloWorld API with Flask, a popular web microframework originally released in 2010
    2. create some xUnit style unit tests for the service
    3. how to integrate this into Jenkins with JUnit test reporting support

The API is a simple Hello World web application with essentially three routes: / , /hello/, and /hello/<name>, where name is any name you desire.

Its better to use something like VirtualEnv to keep pip packages installed for this project separate from system packages or else you can use a python container to build & test your use cases.

After installing Python and optionally initializing a virtual environment, we will need to install the Flask web-microframework as well as the WSGI (Web Service Gateway Interface) server Werkzeug. We can do this by creating a package manifest called requirements.txt and then installing the packages with pip using these bash commands:

You can try the server out with python app.py or with:

# make script executable & run service
chmod +x app.py
./app.py &

# test the server 
curl -i localhost:5000/
curl -i localhost:5000/hello/
curl -i localhost:5000/hello/Ajoy

As we tested the application with three routes: / , /hello/, and /hello/Simon. Now we can write some tests to test these routes.
Create the Tests

Run this in bash to create our test cases:

To run the tests, we simply run something like:

./test.py



Jenkins has the ability present test results in a graphical visual way, as long as you can output the results in a JUnit format. JUnit is a popular xUnit type of test framework, and JUnit output format (an XML file) is ubiquitous test reporting. Essentially, any CI (Continuous Integration) solution will support this format, including Jenkins.

For this integration, we can use the XMLRunner library, and pass this as our test runner to the unittest.main() method.

Insert these few lines at the bottom of the script app.py so that it looks like this:

if __name__ == '__main__':
    ############# Add these lines #############
    import xmlrunner
    runner = xmlrunner.XMLTestRunner(output='test-reports')
    unittest.main(testRunner=runner)
    ###########################################
    unittest.main()

This will import a library called xmlrunner and do a unittest.main() run with XMLTestRunner. After, will do another run to show output to the standard output. This will generate test reports in the test-reports directory.

We need to update the Jenkinsfile to have a final post step in the test stage, that tells Jenkins where to find the JUnit test report. Update Jenkinsfile to look like this:

    stage('test') {
      steps {
        sh 'python test.py'
      }
      post {
        always {
          junit 'test-reports/*.xml'
        }


In Jenkins, run this pipeline.



To create a basic Pipeline through the Jenkins classic UI:

    If required, ensure you are logged in to Jenkins.

    From the Jenkins home page (i.e. the Dashboard of the Jenkins classic UI), click New Item at the top left.



In the Enter an item name field, specify the name for your new Pipeline project.
Caution: Jenkins uses this item name to create directories on disk. It is recommended to avoid using spaces in item names, since doing so may uncover bugs in scripts that do not properly handle spaces in directory paths.

Scroll down and click Pipeline, then click OK at the end of the page to open the Pipeline configuration page (whose General tab is selected).



Click the Pipeline tab at the top of the page to scroll down to the Pipeline section.
Note: If instead you are defining your Jenkinsfile in source control, follow the instructions in In SCM below.

In the Pipeline section, ensure that the Definition field indicates the Pipeline script option.

Enter your Pipeline code into the Script text area.
For instance, copy the following Declarative example Pipeline code (below the Jenkinsfile ( …​ ) heading) or its Scripted version equivalent and paste this into the Script text area. (The Declarative example below is used throughout the remainder of this procedure.)
Jenkinsfile (Declarative Pipeline)

pipeline {
    agent any 
    stages {
        stage('Stage 1') {
            steps {
                echo 'Hello world!' 
            }
        }
    }
}

	agent instructs Jenkins to allocate an executor (on any available agent/node in the Jenkins environment) and workspace for the entire Pipeline.
	echo writes simple string in the console output.
	node effectively does the same as agent (above).



Click Save to open the Pipeline project/item view page.

On this page, click Build Now on the left to run the Pipeline.



Under Build History on the left, click #1 to access the details for this particular Pipeline run.

Click Console Output to see the full output from the Pipeline run. The following output shows a successful run of your Pipeline.

P.S:

        You can also access the console output directly from the Dashboard by clicking the colored globe to the left of the build number (e.g. #1).

        Defining a Pipeline through the classic UI is convenient for testing Pipeline code snippets, or for handling simple Pipelines or Pipelines that do not require source code to be checked out/cloned from a repository. For greater control and flexibility over your Pipeline, particularly for projects in source control that are likely to gain complexity, it is recommended that you use source control to define your Jenkinsfile.

